# SAT 11TH, MARCH FULLY WORKING TRAFFIC FILTER

filter {
    if "PAN-OS_syslog" in [tags] {
            # Log types are "TRAFFIC", "THREAT", "CONFIG", "SYSTEM", "USERID" and "HIP-MATCH".
            # Traffic log fields: https://docs.paloaltonetworks.com/pan-os/10-0/pan-os-admin/monitoring/use-syslog-for-monitoring/syslog-field-descriptions/traffic-log-fields.html
            # converted field names to CIM fields where possible, allows use of CIM Traffic visualitations and reports 

            if ([message] =~ /TRAFFIC/) {
                csv {
                    source => "message"
                    columns => ["FUTURE_USE","Receive_Time","Serial_Number","Type","Threat/Content_Type","FUTURE_USE","Generated_Time","Source_Address","Destination_Address",
                                "NAT_Source_IP","NAT_Destination_IP","Rule_Name","Source_User","Destination_User","Application","Virtual_System","Source_Zone","Destination_Zone",
                                "Inbound_Interface","Outbound_Interface","Log_Action","FUTURE_USE","Session_ID","Repeat_Count","Source_Port","Destination_Port","NAT_Source_Port",
                                "NAT_Destination_Port","Flags","Protocol","Action","Bytes","Bytes_Sent","Bytes_Received","Packets","Start_Time","Elapsed_Time","Category",
                                "FUTURE_USE","Sequence_Number","Action_Flags","Source_Country","Destination_Country","FUTURE_USE","Packets_Sent","Packets_Received",
                                "Session_End_Reason","Device_Group_Hierarchy_Level_1","Device_Group_Hierarchy_Level_2","Device_Group_Hierarchy_Level_3",
                                "Device_Group_Hierarchy_Level_4","Virtual_System_Name","Device_Name","Action_Source","Source_VM_UUID","Destination_VM_UUID","Tunnel_ID/IMSI",
                                "Monitor_Tag/IMEI","Parent_Session_ID","Parent_Start_Time","Tunnel_Type","SCTP_Association_ID","SCTP_Chunks","SCTP_Chunks_Sent","SCTP_Chunks_Received",
                                "Rule_UUID","HTTP/2_Connection","App_Flap_Count","Policy_ID","Link_Switches","SD-WAN_Cluster","SD-WAN_Device_Type","SD-WAN_Cluster_Type","SD-WAN_Site",
                                "Dynamic_User_Group_Name","XFF_Address","Source_Device_Category","Source_Device_Profile","Source_Device_Model","Source_Device_Vendor",
                                "Source_Device_OS_Family","Source_Device_OS_Version","Source_Hostname","Source_Mac_Address","Destination_Device_Category","Destination_Device_Profile",
                                "Destination_Device_Model","Destination_Device_Vendor","Destination_Device_OS_Family","Destination_Device_OS_Version","Destination_Hostname",
                                "Destination_Mac_Address","Container_ID","POD_Namespace","POD_Name","Source_External_Dynamic_List","Destination_External_Dynamic_List","Host_ID",
                                "Serial_Number","Source_Dynamic_Address_Group","Destination_Dynamic_Address_Group","Session_Owner","High_Resolution_Timestamp","A_Slice_Service_Type",
                                "A_Slice_Differentiator"]
                }
                # Most of the new fields in PANOS 10 are not enabled yet, so they are pruned, will add them to the whitelist as they become available
                # But note, default to is store the entire raw message so no data is lost as you can interogate the message field
                # Also, some fields like rule_uuid are pruned as rule name is avaiable.  If you need the UUID you can see it in the message field
    #            prune {
    #                interpolate => true
    #                whitelist_names => ["@timestamp","message","receive_time","serial_number","log_type","content_type","generated_time","source_address","Destination_Address","src_translated_ip",
    #                                    "dest_translated_ip","rule","user","dest_user","app","virtual_system","src_zone","dest_zone","src_interface","dest_interface",
    #                                    "log_profile","session_id","repeat_count","src_port","dest_port","src_translated_port","dest_translated_port","protocol",
    #                                    "action","bytes","bytes_out","bytes_in","packets","start","elapsed_sec","category","seqno","action_flags","src_location",
    #                                    "dest_location","packets_out","packets_in","session_end_reason","dvc_name","action_source","tunnelid","tunnel","http-2-connection"]
    #                    }
    #            # MUTATE TRAFIC
            mutate {
                    convert => [ "Bytes", "integer" ]
                    convert => [ "Bytes_Received", "integer" ]
                    convert => [ "Bytes_Sent", "integer" ]
                    convert => [ "Elapsed_Time", "integer" ]
                    convert => [ "geoip.dma_code", "integer" ]
                    convert => [ "geoip.latitude", "float" ]
                    convert => [ "geoip.longitude", "float" ]
                    # GET DOMAIN NAME
                    #convert => [ "geoip.domain", "string"]
                    # ASN NUMBER ADDED
                    convert => [ "geoip.asn", "integer"]
                    # ORGANIZATION ADDED
                    convert => [ "geoip.organization", "string"]
                    convert => [ "Destination_Port", "integer" ]
                    convert => [ "Source_Port", "integer" ]
                    convert => [ "Packets", "integer" ]
                    convert => [ "Packets_Received", "integer" ]
                    convert => [ "Packets_Out", "integer" ]
                    convert => [ "Sequence_Number", "integer" ]
                    # ADD TAG TO MESSAGE
                    add_tag => [ "PAN-OS_Traffic"]
                    # Original message has been fully parsed, so remove it.
                    remove_field => [ "message" ]
                    remove_field => ["High_Resolution_Timestamp"]
                    remove_field => ["Sequence_Number"]
                    remove_field => ["event"]
                    remove_field => ["Source_Country"]
                    remove_tag   => ["PAN-OS_syslog"]
                }
                
                # Added geoip destinations
                geoip {
                    source                => "Destination_Address"
                    target                => "destination_geo"
                    default_database_type => "ASN"
                    tag_on_failure        => []
                }

                geoip {
                    source                 => "Source_Address"
                    target                 => "source_geo"
                    default_database_type  => "ASN"
                    tag_on_failure         => []
                }

                geoip {
                    source                => "Destination_Address"
                    target                => "destination_geo"
                    default_database_type => "City"
                    tag_on_failure        => []
                }

                geoip {
                    source                => "Source_Address"
                    target                => "source_geo"
                    default_database_type => "City"
                    tag_on_failure        => []
                }
                geoip {
                    source => "Destination_Address"
                    target => "destination_geo"
                    add_field => [ "[destination_geo][location]", "%{[destination_geo][longitude]}" ]
                    add_field => [ "[destination_geo][location]", "%{[destination_geo][latitude]}"  ]
                    tag_on_failure => []
                }

                # DOUBLE CHECK THIS ########!!!!!
                date {
                    match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
                    target => "parsed_timestamp"
                }

                # Non-RFC1918 address only, will skip all 127.0.0.1, 10.0.0.0/8, 172.16.0.0/16 192.168.0.0/24
                # if [Source_Address] and [Source_Address] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {

                #     geoip {
                #         source => "Source_Address"
                #         target => "SourceGeographical"
                #     }
                #     #Delete 0,0 in SourceGeographical.location if equal to 0,0
                #     if ([SourceGeographical.location] and [SourceGeographical.location] =~ "0,0") {
                #         mutate {
                #         replace => [ "SourceGeographical.location", "" ]
                #         }
                #     }
                # }
                
                # Non-RFC1918 address only, will tag all 127.0.0.1, 10.0.0.0/8, 172.16.0.0/16 192.168.0.0/24
                if [Source_Address] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
                    mutate {
                        add_tag => [ "internal_source" ]
                    }
                } else {
                    mutate {
                        add_tag => [ "external_source" ]
                    }
                }


                # # Non-RFC1918 address only, will skip all 127.0.0.1, 10.0.0.0/8, 172.16.0.0/16 192.168.0.0/24
                # if [Destination_Address] and [Destination_Address] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
                #     geoip {
                #         source => "Destination_Address"
                #         target => "Geographical_Destination"
                #     }
                # # Delete 0,0 in Geographical_Destination.location if equal to 0,0
                # if ([Geographical_Destination.location] and [Geographical_Destination.location] =~ "0,0") {
                #     mutate { replace => [ "Destination_Address.location", "" ] }
                #     }
                # }    
                # Non-RFC1918 address only, will tag all 127.0.0.1, 10.0.0.0/8, 172.16.0.0/16 192.168.0.0/24
                if [Destination_Address] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
                    mutate {
                        add_tag => [ "internal_destination" ]
                        }
                }

                else {
                    mutate {
                        add_tag => [ "external_destination" ]
                        }
                }

                # # IDS rules may flip source and destination based on how the rule
                # # is written. Use tag to find external IPs before checking DNS
                # if "external_source" in [tags] {
                #     elasticsearch {
                #             query    => "log_event_type:dns AND answers:%{Source_Address}"
                #             index    => "panos-traffic-%{+YYYY.MM.dd}"
                #             hosts    => ["stash.csuci.edu:9200"]
                #             user     => "logstash_internal"
                #             password => "${LOGSTASH_INTERNAL_PASSWORD}"

                #             fields => {
                #                     "query" => "query"
                #             }
                #     }
                # }

                # if "external_destination" in [tags] {
                #     elasticsearch {
                #             query    => "log_event_type:dns AND answers:%{Destination_Address}"
                #             index    => "panos-traffic-%{+YYYY.MM.dd}"
                #             hosts    => ["stash.csuci.edu:9200"]
                #             user     => "logstash_internal"
                #             password => "${LOGSTASH_INTERNAL_PASSWORD}"
                            
                #             fields => {
                #                     "query" => "query"
                #             }
                #     }
                # }

                # Resolve IP address to names.  The DNS filter can be a performance issue is receing over 400 requstes per second.
                # Do not use Logstash DNS Filter Cache parameters, it forces a single thread process regaurdless of how many workers you have
                # For best performance, install dnsmasq on the logstash server
                # Make sure your dnsmasq points to an internal DNS to resolve local RFC1918 addresses
                if [Source_Address] {
                    mutate {
                        add_field => { "source_ip_resolved" => "%{Source_Address}" }
                    }   
                    dns {
                        reverse        => [ "source_ip_resolved"] 
                        action         => "replace"
                        add_field      => { "dns_lookup" => "%{[source_ip_resolved]}" }
                        hit_cache_size => 4096
                        # Your own private DNS SERVERS should go here
                        nameserver     => [ "10.121.11.5", "10.121.11.8" ]
                        timeout        => 1
                    }     
                }        
                if [Destination_Address] {
                        mutate {
                            add_field => { "dest_name" => "%{Destination_Address}" }
                        }   
                        dns {
                            reverse        => [ "dest_name"] 
                            action         => "replace"
                            add_field      => { "dns_lookup" => "%{[dest_name]}" }
                            hit_cache_size => 4096
                            # Your own private DNS SERVERS should go here
                            nameserver     => [ "10.121.11.5", "10.121.11.8" ]
                            timeout        => 1                        
                        }   
                }
        }
    }
}
